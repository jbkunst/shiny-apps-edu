---
title: "Decision Tree"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    theme:
      version: 4
      primary: "#262162"
      navbar-bg: "#262162"
      base_font:
        google: "IBM Plex Sans"
editor_options: 
  chunk_output_type: console
runtime: shiny
---

```{r global, include=FALSE}
library(tidyverse)
library(shiny)
# library(thematic)

library(partykit)
library(parttree) # remotes::install_github("grantmcdermott/parttree")
library(scales)

library(risk3r)       # remotes::install_github("jbkunst/risk3r")
library(geomtextpath) # remotes::install_github("AllanCameron/geomtextpath")
# library(xtable)

primary_color <- "#262162"

# thematic_shiny(font = "auto")
theme_set(theme_minimal() + theme(legend.position = "bottom"))
```

<style>
.irs-grid-pol.small {
  height: 0px;
}

.form-group {
  margin-bottom: 0.5rem;
  margin-top:    0.5rem;
}
</style>

Column { .sidebar data-width=300 }
-----------------------------------------------------------------------

<hr/>

```{r inputs}
radioButtons(
  "relationship",
  tags$span("Relationship between \\(x\\), \\(y\\) and the response variable"),
  choices = list(
    "\\(x > y\\)" = "x > y",
    "\\(x^2 > y\\)" = "x^2 - y > 0",
    "\\(|x| > |y|\\)" = "abs(x) - abs(y) > 0",
    "\\(x^2 + y^2 < 0.5\\)" = "x^2 + y^2 < 0.5",
    "\\( \\sin(x \\cdot \\pi ) > \\sin(y \\cdot \\pi ) \\)" = "sin(x*pi) > sin(y*pi)"
  )
)

# checkboxInput(
#   "show_xy_rel",
#   label = "Show relationship between \\( x \\)  and \\( y \\))"
# )

sliderInput(
  "percent_noise",
  tags$span("Percent noise"),
  min = 0,
  max = 50,
  step = 5,
  value = 20,
  post = "%"
)

sliderInput(
  "depth",
  tags$span("Maximum depth of the tree"),
  min = 1,
  max = 8,
  step = 1,
  value = 2
)

sliderInput(
  "alpha",
  tags$span("Significance level for variable selection \\( \\alpha \\)"),
  min = 0,
  max = 1,
  step = 0.05,
  value = .1
)

sliderInput(
  "n",
  tags$small("Number of observartions"),
  min = 100,
  max = 1000,
  step = 100,
  value = 500
)

# checkboxInput(
#   "apply_stepwise", 
#   tags$small("Apply stepwise"),
#   value = FALSE
# )

checkboxInput(
  "show_model_field", 
  tags$small("Show model predicctions"),
  value = TRUE
)
```


```{r reactives-server, include=FALSE}
# input <- list(
#   n = 500,
#   relationship = "x > y",
#   show_model_field = TRUE,
#   show_xy_rel = TRUE,
#   percent_noise = 10,
#   depth = 8,
#   alpha = 0.05
# ); input

dxy <- reactive({

  set.seed(1234)
  
  dxy <- tibble(
    x = runif(input$n, -1, 1),
    y = runif(input$n, -1, 1)
  )
  
  dxy <- dxy |>
    mutate(
      response := eval(parse(text = input$relationship))
      # response = sin(x*pi) > sin(y*pi)  
      )

  dxy <- dxy |>
    mutate(
      response = ifelse(
        runif(input$n) < input$percent_noise/100,
        !response,
        response
        )
      )
  
  dxy <- dxy |>
    # select(r response = )
    # set_names(c("v1", "v2", "r")) |>
    mutate(response = factor(response, levels = c("TRUE", "FALSE")))
  
  # glimpse(dxy)
  
  dxy

})

mod <- reactive({

  dxy <- dxy()
  
  mod <- ctree(
    response ~ x + y,
    data = dxy,
    control = ctree_control(maxdepth = input$depth, alpha = input$alpha)
    )

  mod

})

# dgrd <- reactive({
# 
#   dxy <- dxy()
#   mod  <- mod()
# 
#   dgrd <- crossing(
#     x = seq(-1, 1, by = 0.05),
#     y = seq(-1, 1, by = 0.05)
#     )
#   
#   if(input$order > 1){
#     
#     pwr <- function(x, p) { x**p }
#     
#     fns <- map(2:input$order, ~ partial(pwr, p = .x)) |> 
#       set_names(str_c(2:input$order))
#     
#     dgrd <- dgrd |> 
#       mutate(across(x:y, .fns = fns)) 
#     
#   }
#   
#   dgrd <- dgrd |>
#     mutate(pred = predict(mod, newdata = dgrd, type = "response"))
# 
#   dgrd
# 
# })
```

Row {data-height=700}
-----------------------------------------------------------------------

### 

```{r}
renderPlot({
  
  dxy <- dxy()
  mod <- mod()
  # dgrd <- dgrd()
  
  p <- ggplot(dxy) 
  
  if(input$show_model_field) {

    p <- p +
      # predictions
      geom_parttree(
      data = mod,
      aes(fill = response), 
      alpha = 0.2, 
      color = "gray70",
      size = 0.1
      ) +
      scale_fill_manual(name = NULL, values = c(muted("blue"), muted("red"))) 
    
  }
  
  p <- p +  
    # data
    geom_point(
      aes(x, y, color = factor(response), shape = factor(response)),
      data = dxy,
      size = 3
      ) +
    
    scale_shape_manual(name = NULL, values = c(1, 4)) +
    scale_color_manual(name = NULL, values = c(muted("blue"), muted("red"))) +

    theme(legend.key.width = unit(2, "cm"))
  
  p

})
```

### 

```{r}
# renderPlot({
#   
#   dxy <- dxy()
#   mod  <- mod()
#   
#   dxy <- dxy |>
#     mutate(pred = predict(mod, newdata = dxy, type = "response"))
#   
#   dg <- dxy |>
#     select(x, y, response) |> 
#     gather(key, value, -response) |>
#     mutate(key = str_glue("variable {key}"))
#   
#   p <- ggplot() +
#     # data
#     geom_point(
#       data = dg,
#       aes(value, as.numeric(response), color = factor(response), shape = factor(response)),
#       size = 3,
#       alpha = 0.5,
#       position = position_jitter(height = 0.05)
#       ) +
#     
#     scale_shape_manual(name = NULL, values = c(1, 4)) +
#     scale_color_manual(name = NULL, values = c(muted("blue"), muted("red"))) +
#     
#     scale_y_continuous(
#       breaks = c(0, 1),
#       labels = c("FALSE\n(response = 0)", "TRUE\n(response = 1)")
#       ) +
#     
#     # predictions
#     
#     # geom_smooth(
#     #   color = primary_color, size = 1.2, alpha = 0.1, 
#     #   method = "loess", formula  = y ~ x
#     #   ) +
#     
#     labs(
#       x = NULL,
#       y = NULL
#     ) +
#     
#     facet_wrap(vars(key))
#   
#   if(input$show_model_field) {
#     
#     dg2 <- dxy |>
#       select(x, y, pred) |> 
#       gather(key, value, -pred) |>
#       mutate(key = str_glue("variable {key}"))
#     
#     p <- p + 
#       geom_smooth(
#         data = dg2,
#         aes(value, pred),
#         color = primary_color
#       )
#     
#   }
#   
#   p
#   
# })
```

Row
-----------------------------------------------------------------------

### 

```{r}
renderPlot({
  
  mod <- mod()
  
  aucroc <- Metrics::auc(
    actual = mod$data$response == "TRUE",
    predicted = as.numeric(predict(mod, type = "prob")[,1])
    )
 
  droc <- risk3r::roc_data(
    mod$data$response == "TRUE", 
    as.numeric(predict(mod, type = "prob")[,1])
  )
  
  ggplot(droc) +
    geom_line(aes(x, y), size = 2, color = primary_color) +
    labs(title = str_glue("AUC: { percent(aucroc)  }")) +
    theme(legend.position = "none") +
    ggplot2::labs(x = "False positive rate (FPR)", 
                  y = "True positive rate (TPR)")
  
})
```

### 

```{r}
renderPlot({
  
  mod <- mod()

  ksmod <- risk3r::ks(
    actual = mod$data$response == "TRUE",
    predicted = as.numeric(predict(mod, type = "prob")[,1])
    )
  
  dprd <- mod$data |> 
    as_tibble() |> 
    mutate(pred = predict(mod, newdata = mod$data, type = "prob")[, 1])
  
  ggplot(dprd, aes(pred, group = response, fill = response, color = response, label = response)) +
    geom_density(alpha = 0.1, size = 2) +
    
    scale_color_manual(name = NULL, values = c(muted("red", 35), muted("blue", 35))) +
    
    geom_textdensity(size = 4, fontface = 1, hjust = 0.2, vjust = -0.5) +
    scale_y_continuous(labels = NULL) +
    scale_x_continuous(limits = c(0, 1)) + 
    labs(x = "Probability", y = "Density") +
    labs(title = str_glue("KS: { percent(ksmod) }")) +
    theme(legend.position = "none")
  
})
```

### 

```{r}
# renderTable({
# # renderUI({
#   
#   mod <- mod()
#   
#   dmod <- tidy(mod) |> 
#     mutate(
#       # term =  str_c(
#       #   str_extract(term, "poly\\([x|y]") |> str_remove("poly\\("),
#       #   "^",
#       #   str_extract(term, "[0-9]{0,1}$")
#       #   ),
#       # term = coalesce(term, "(Intercept)"),
#       # term = str_remove(term, "\\^$"),
#       # term = str_glue("\\( {term} \\)"),
#       term = str_replace_all(term, "_", "^"),
#       # term = str_c("\\( ", term, " \\)"),
#       ` ` = symnum(p.value, corr = FALSE, na = FALSE, legend = FALSE,
#                    cutpoints = c(0, 0.001, 0.01, 0.05, 0.1, 1),
#                    symbols = c("***", "**", "*", ".", " "))
#       )
#   
#   dmod
#   
#   # dmod <- dmod |> tibble::column_to_rownames("term")
#   # 
#   # LaTeXtab <- print(
#   #   xtable(dmod, align=rep("c", ncol(dmod)+1)), 
#   #   floating = FALSE,
#   #   tabular.environment = "array",
#   #   comment = FALSE,
#   #   print.results = FALSE,
#   #   sanitize.rownames.function = identity
#   #   )
#   # 
#   # tagList(
#   #   withMathJax(),
#   #   HTML(paste0("$$", LaTeXtab, "$$"))
#   #   )
#   
# })
```

