---
title: "K-means"
output:
  flexdashboard::flex_dashboard:
    orientation: rows
    theme:
      version: 4
      primary: '#262162'
      navbar-bg: '#262162'
      base_font:
        google: IBM Plex Sans
runtime: shiny
editor_options: 
  chunk_output_type: console
---

```{r global, include=FALSE}
library(shiny)
library(shinyWidgets)
library(tidyverse)

primary_color <- "#262162"

theme_set(theme_minimal() + theme(legend.position = "bottom"))
```

<style>
.irs-grid-pol.small {
  height: 0px;
}

.form-group {
  margin-bottom: 0.5rem;
  margin-top:    0.5rem;
}

.sidebar {
  padding-top: 1rem;
}

</style>

Controls { .sidebar data-width=300 }
-----------------------------------------------------------------------

```{r inputs}
shiny::sliderInput(
  "n_groups",
  tags$span("Number of groups to simulate"),
  value = 3,
  min = 1,
  max = 10
)

shiny::sliderInput(
  "n",
  tags$span("Number of points to simulate"),
  value = 300,
  min = 100,
  max = 500,
  step = 100
)

shiny::sliderInput(
  "k",
  tags$span("Parameter \\(k\\) for \\(K\\)-Means"),
  value = 4,
  min = 2,
  max = 10
)

shinyWidgets::sliderTextInput(
  "iter",
  tags$span("Iterations of algorithm"),
  choices = 0:15,
  selected = 4,
  grid = TRUE,
  # step = 1,
  # min = 0,
  # max = 15,
  # animate = TRUE,
  animate = animationOptions(interval = 2000)
)
```

<hr/>

<small>
```{r}
htmltools::includeMarkdown("readme.md")
```
</small>


```{r reactives, context="server"}
# input <- list(
#   n_groups = 4,
#   n = 150,
#   k = 3,
#   iter = 2
#   ); input

# input <- list(
#   n_groups = 3,
#   n = 500,
#   k = 5,
#   iter = 2
#   ); input

Posdef <- function (n, ev = runif(n, 0, 10)) {
  # https://stat.ethz.ch/pipermail/r-help/2008-February/153708
  Z <- matrix(ncol = n, rnorm(n ^ 2))
  decomp <- qr(Z)
  Q <- qr.Q(decomp)
  R <- qr.R(decomp)
  d <- diag(R)
  ph <- d / abs(d)
  O <- Q %*% diag(ph)
  Z <- t(O) %*% diag(ev) %*% O
  return(Z)
}

data_gen <- function(n = 1000, groups = 3, seed = 123) {
  
  set.seed(seed)
  
  seq_len_groups <- seq_len(groups)
  
  mus <-
    purrr::map(seq_len_groups, ~ runif(2, min = -10, max = 10))
  
  sigmas <- purrr::map(seq_len_groups, function(k) {
    Posdef(2)
    
  })
  
  props <- rbeta(groups, 5, 5)
  props <- props / sum(props)
  
  ns <- round(n * props)
  
  dpars <- tibble(n = ns, mu = mus, Sigma = sigmas)
  
  data <- pmap(dpars, MASS::mvrnorm) |>
    map(as_tibble, .name_repair = "minimal") |>
    map(set_names, c("x", "y")) |>
    map2_df(seq_len_groups, ~ mutate(.x, group = .y, .before = 1))
  
  data
  
}

kmeans_iterations <- function(data, k = 3, tolerance = 10e-6, seed = 123, max_iterations = 20) {
  
  set.seed(seed)
  
  daux <- data |>
    mutate(id = row_number(), .before = 1) |>
    mutate(cluster = 0)
  
  dcenters <- daux |>
    sample_n(k) |>
    select(cx = x, cy = y) |>
    arrange(cx, cy) |>
    mutate(cluster = row_number(), .before = 1)
  
  center_hist <- list(dcenters)
  data_hist   <- list(daux)
  
  iteration <- 1
  
  while (TRUE) {
    # message(iteration)
    
    daux <- crossing(daux |> select(id, group, x, y),
                     dcenters) |>
      mutate(dist = (x - cx) ^ 2 + (y - cy) ^ 2) |>
      group_by(id) |>
      # new cluster
      filter(dist == min(dist)) |>
      ungroup()
    
    daux
    # daux |> count(group, cluster)
    
    dcenters <- daux |>
      group_by(cluster) |>
      # new centers
      summarise(cx = mean(x), cy = mean(y))
    
    dcenters
    
    daux <- daux |>
      select(id, group, x, y, cluster)
    
    daux
    
    center_hist <- append(center_hist, list(dcenters))
    data_hist   <- append(data_hist, list(daux))
    
    c1 <- last(center_hist) |> select(cx, cy) |> as.matrix()
    c2 <- nth(center_hist, -2) |> select(cx, cy) |> as.matrix()
    
    if (mean((c1 - c2) ^ 2) < tolerance)
      break
    
    if (iteration == max_iterations)
      break
    
    iteration <- iteration + 1
    
    
  }
  
  # length(center_hist)
  # length(data_hist)
  
  seq_along_i <- seq_len(length(center_hist))
  
  # -1 for setup
  center_hist <- map2_df(center_hist,
                         seq_along_i,
                         ~ mutate(.x, iteration = .y - 1, .before = 1))
  
  data_hist <- map2_df(data_hist,
                       seq_along_i,
                       ~ mutate(.x, iteration = .y - 1, .before = 1))
  
  list(data_hist = data_hist, center_hist = center_hist)
  
}

data <- reactive({

  data <- data_gen(n = input$n, groups = input$n_groups, seed = sample(1:100, size = 1))

  data

})

# k means iterations all
kmi_all <- reactive({
  
  data <- data()
  
  ks <- 1:10
  
  kmi_all <- map(ks, ~ kmeans_iterations(data = data, k = .x))
  
  kmi_all
  
  
})

# k means iteration (for actual selected k)
kmi <- reactive({
  
  kmi_all <- kmi_all()
  
  kmi <- kmi_all[[input$k]]
  
  # updateSliderInput
  updateSliderTextInput(
    session = getDefaultReactiveDomain(),
    inputId = "iter",
    choices = 0:max(kmi$center_hist$iteration),
    selected = sample(0:max(kmi$center_hist$iteration), size = 1)
    )
  
  kmi
  
})

kmi_plot <- reactive({
  
  kmi <- kmi()
  
  dh <- kmi$data_hist |> 
    mutate(across(c(group, cluster), as.factor))
  
  dc <- kmi$center_hist |> 
    mutate(across(c(cluster), as.factor))
  
  # dh |> count(group, iteration) |> spread(iteration, n)
  # dh |> count(cluster, iteration) |> spread(iteration, n)
  
  k <- input$k
  
  colors <- viridisLite::viridis(k, begin = 0.1, end = .9)
  colors <- set_names(colors, seq_len(k))
  colors <- c("Start" = "gray70", colors)
  
  # scales::show_col(colors)
  
  kmi_plot <- ggplot() +
    facet_wrap(vars(iteration)) +
    geom_point(
      data = dh,
      aes(x, y, group = id, color = cluster, shape = group),
      size = 3,
      alpha = 0.5
    ) +
    # kunstomverse::geom_point2
    geom_point(
      data = dc,
      aes(cx, cy, group = cluster, fill = cluster),
      size = 6,
      alpha = 1,
      shape = 21,
      ) +
    labs(shape = "(Original) Group") +
    scale_color_manual(values = colors, name = "(Assigned) Cluster") +
    scale_fill_manual(values = colors, name = "(Assigned) Cluster") +
    theme(legend.position = "right")
  
  kmi_plot

})

data_elbow <- reactive({
  
  kmi_all <- kmi_all()
  
  ks <- 1:10
  
  data_hist_all <- kmi_all |> 
    map(pluck, "data_hist") |> 
    # map(filter, iteration == max(iteration)) |> 
    # map(select, -iteration, -id) |> 
    map2_df(ks, ~ mutate(.x, k = .y, .before = 1))
  
  data_hist_all <- data_hist_all |> 
    # filter(k == 2) |> 
    # distance from cluster
    group_by(k, iteration, cluster) |> 
    mutate(xc = mean(x), yc = mean(y)) |> 
    mutate(dc = (x - xc)^2 + (y - yc)^2) |> 
    # distance from total center
    ungroup() |> 
    group_by(k, iteration) |> 
    mutate(xt = mean(x), yt = mean(y)) |> 
    mutate(dt = (x - xt)^2 + (y - yt)^2) |> 
    ungroup()
  
  data_elbow <- data_hist_all |> 
    group_by(k, iteration) |> 
    summarise(dc = sum(dc), dt = sum(dt)) |> 
    mutate(wc = 1 - dc/dt) |> 
    ungroup()
  
  data_elbow
  
})


```

Row {data-height=500}
-----------------------------------------------------------------------

### 

```{r}
plotOutput("iter_plot", width = "100%", height = "100%")
```

```{r, context="server"}
output$iter_plot <- renderPlot({
# output$iter_plot <- renderCachedPlot({

  kmi_plot <- kmi_plot()
  
  kmi_plot +
    ggforce::facet_wrap_paginate(
      vars(iteration),
      nrow = 1,
      ncol = 1,
      page = input$iter + 1
      )

})
# }, cacheKeyExpr = { list(input$n_groups, input$n, input$k, input$iter)})
```


Row
-----------------------------------------------------------------------

### 

```{r}
plotOutput("elbow", width = "100%", height = "100%")
```

```{r, context="server"}
output$elbow <- renderPlot({
  
  data_elbow <- data_elbow()
  
  daux <- data_elbow |> 
    group_by(k) |> 
    filter(iteration == max(iteration)) |> 
    ungroup()
  
  ggplot(daux, aes(k, 1 - wc)) +
    geom_line(size = 1.2, color = "gray60") +
    # kunstomverse::geom_point2
    geom_point(
      data = filter(daux, k == input$k),
      shape = 21, 
      size = 5,
      color = "white", 
      fill = primary_color
      ) +
    scale_x_continuous(breaks = 1:10, minor_breaks = NULL)
  
})
```

### 

```{r}
plotOutput("convergence", width = "100%", height = "100%")
```

```{r, context="server"}
output$convergence <- renderPlot({
  
  data_elbow <- data_elbow()
  
  daux <- data_elbow |> 
    filter(k == input$k, iteration > 0) |> 
    ungroup()
  
  ggplot(daux, aes(iteration, 1 - wc)) +
     geom_line(size = 1.2, color = "gray60") +
     geom_point(
      data = filter(daux, iteration == input$iter),
      shape = 21, 
      size = 5,
      color = "white", 
      fill = primary_color
      ) +
    scale_x_continuous(breaks = daux$iteration, minor_breaks = NULL)

})
```


